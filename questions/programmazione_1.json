[
    {
        "question": "Quando parliamo di: 'una descrizione delle operazioni che devono essere eseguite per risolvere una certa classe di problemi', stiamo definendo un...",
        "answer_1": "programma",
        "answer_2": "algortimo",
        "answer_3": "diagramma",
        "answer_4": "flow chart",
        "currect_answer": "answer_1",
        "module": "modulo 1_1",
	    "paragraph": "Algoritmi e programmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Quando parliamo di: 'una successione ordinata di istruzioni (o passi) che definiscono le operazioni da eseguire su dei dati per risolvere una classe di problemi' ci riferiamo alla definizione di:",
        "answer_1": "programma",
        "answer_2": "algortimo",
        "answer_3": "diagramma",
        "answer_4": "flow chart",
        "currect_answer": "answer_2",
        "module": "modulo 1_1",
	    "paragraph": "Algoritmi e programmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Le proprietà degli algoritmi sono:",
        "answer_1": "infinitezza, generalità e ambiguità",
        "answer_2": "finitezza, generalità e non ambiguità",
        "answer_3": "finitezza, generalità e ambiguità",
        "answer_4": "finitezza, specificità e non ambiguità",
        "currect_answer": "answer_2",
        "module": "modulo 1_1",
	    "paragraph": "Algoritmi e programmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Un flow chart è un:",
        "answer_1": "linguaggio informale di tipo grafico per rappresentare gli algoritmi",
        "answer_2": "linguaggio formale di tipo testuale per rappresentare gli algoritmi",
        "answer_3": "linguaggio informale di tipo testuale per rappresentare gli algoritmi",
        "answer_4": "linguaggio formale di tipo grafico per rappresentare gli algoritmi",
        "currect_answer": "answer_4",
        "module": "modulo 1_1",
	    "paragraph": "Rappresentazione degli Algoritmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "La scelta, in un diagramma di flusso, è rappresentata da un:",
        "answer_1": "rettangolo",
        "answer_2": "quadrato",
        "answer_3": "rombo",
        "answer_4": "cerchio",
        "currect_answer": "answer_3",
        "module": "modulo 1_1",
	    "paragraph": "Rappresentazione degli Algoritmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Le fasi per descrivere un algortitmo con pseudocodifica sono:",
        "answer_1": "intestazione, dichiarativa, esecutiva",
        "answer_2": "intestazione, dichiarativa, scrittura dei risultati",
        "answer_3": "intestazione,acquisizione dei dati, esecutiva",
        "answer_4": "assegnazione, dichiarativa, esecutiva",
        "currect_answer": "answer_1",
        "module": "modulo 1_1",
	    "paragraph": "Rappresentazione degli Algoritmi",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Le caratteristiche di un linguaggio di programmazione sono:",
        "answer_1": "lessico, istruzioni, semantica",
        "answer_2": "alfabeto, sintassi, semantica",
        "answer_3": "lessico, sintassi, semantica",
        "answer_4": "alfabeto, simboli, semantica",
        "currect_answer": "answer_3",
        "module": "modulo 1_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "I linguaggi di programmazione sono classificati per:",
        "answer_1": "livello",
        "answer_2": "complessità",
        "answer_3": "ambiguità",
        "answer_4": "leggerezza",
        "currect_answer": "answer_1",
        "module": "modulo 1_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "L'Assembly è un linguaggio:",
        "answer_1": "di alto livello",
        "answer_2": "di basso livello",
        "answer_3": "vicino all'uomo",
        "answer_4": "macchina",
        "currect_answer": "answer_2",
        "module": "modulo 1_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "Per tradurre un linguaggio ad alto livello in linguaggio macchina si utilizza il:",
        "answer_1": "traduttore",
        "answer_2": "convertitore",
        "answer_3": "codice binario",
        "answer_4": "compilatore",
        "currect_answer": "answer_4",
        "module": "modulo 1_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_1_1"
    },
    {
        "question": "La fase di problem finding corrisponde a",
        "answer_1": "Definire il problema",
        "answer_2": "Rendersi conto del disagio",
        "answer_3": "Passare all'azione",
        "answer_4": "Adottare una soluzione",
        "currect_answer": "answer_2",
        "module": "modulo 2_1",
	    "paragraph": "Problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "La fase di decision making",
        "answer_1": "Corrisponde alla fase di problem solving",
        "answer_2": "Precede la fase di problem finding",
        "answer_3": "Segue la fase di problem solving",
        "answer_4": "Segue la fase di decision taking",
        "currect_answer": "answer_3",
        "module": "modulo 2_1",
	    "paragraph": "Problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "Problem analysis corrisponde a",
        "answer_1": "eliminare le cause e rispondere alle domande proste dal problema",
        "answer_2": "definire il problema",
        "answer_3": "scomporre il problema principalie in secondari",
        "answer_4": "passare all'azione",
        "currect_answer": "answer_3",
        "module": "modulo 2_1",
	    "paragraph": "Problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "Problem setting vuol dire",
        "answer_1": "Decidere come risolvere il problema",
        "answer_2": "Suddividere il problema in sotto problemi",
        "answer_3": "Analizzare il problema per adottare una soluzione",
        "answer_4": "Decidere cosa fare per risolvere il problema",
        "currect_answer": "answer_1",
        "module": "modulo 2_1",
	    "paragraph": "Problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "La fase di decision taking",
        "answer_1": "E' immediatamente successiva alla fase di problem analysis",
        "answer_2": "E' immediatamente successiva alla fase di decision making",
        "answer_3": "Vuol dire decidere come agire",
        "answer_4": "Vuol dire rendersi conto della situaizone problematica",
        "currect_answer": "answer_2",
        "module": "modulo 2_1",
	    "paragraph": "Problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "Quante sono le mosse per un corretto utilizzo delle tecniche di problem solving",
        "answer_1": "6",
        "answer_2": "9",
        "answer_3": "4",
        "answer_4": "5",
        "currect_answer": "answer_1",
        "module": "modulo 2_1",
	    "paragraph": "Tecniche di problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "L'approccio top-down indica",
        "answer_1": "Una scomposizione di problemi semplici in sotto problemi più complessi",
        "answer_2": "Una unione di problemi piccoli in problemi più complessi",
        "answer_3": "un approccio in cui la scomposizione inizia dal livello più basso",
        "answer_4": "un approccio in cui la scomposizione inizia dal livello più alto e prosegue verso il basso",
        "currect_answer": "answer_4",
        "module": "modulo 2_1",
	    "paragraph": "Tecniche di problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "Un flowchart è",
        "answer_1": "utilizzato per illustrare la struttura fisica del problema",
        "answer_2": "Utilizzato per illustrare la struttura logica deò problema",
        "answer_3": "utilizzato per rappresentare solo i cicli",
        "answer_4": "Utilizzato per rappresentare solo sequenze e cicli",
        "currect_answer": "answer_2",
        "module": "modulo 2_1",
	    "paragraph": "Tecniche di problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "Coding vuol dire",
        "answer_1": "Scrivere il programma in pseudo codice",
        "answer_2": "scrivere il programma in un linguaggio formale",
        "answer_3": "Scrivere il programma in un linguaggio di programmazione",
        "answer_4": "Definire il flowchart del problema",
        "currect_answer": "answer_3",
        "module": "modulo 2_1",
	    "paragraph": "Tecniche di problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1" 
    },
    {
        "question": "Quali sono le tipologie di errori di programmazione",
        "answer_1": "Sintattici, fisici, logici",
        "answer_2": "Sintattici, logici, semantici",
        "answer_3": "Logici, semantici, fisici",
        "answer_4": "Sintattici, run-time, logici",
        "currect_answer": "answer_4",
        "module": "modulo 2_1",
	    "paragraph": "Tecniche di problem solving",
        "link_pdf": "programmazione_1/dispensa_2_1"
    },
    {
        "question": "In un flowchart il Terminal è rappresentato da:",
        "answer_1": "Rombo",
        "answer_2": "Rettangolo",
        "answer_3": "Rettangolo arrotondato",
        "answer_4": "Parallelogramma",
        "currect_answer": "answer_3",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: definizione",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "In un flowchart le operazioni di Input/Output sono rappresentate da:",
        "answer_1": "Rombo",
        "answer_2": "Rettangolo",
        "answer_3": "Rettangolo arrotondato",
        "answer_4": "Parallelogramma",
        "currect_answer": "answer_4",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: definizione",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "In un flowchart i processi sono rappresentati da:",
        "answer_1": "Rombo",
        "answer_2": "Rettangolo",
        "answer_3": "Rettangolo arrotondato",
        "answer_4": "Parallelogramma",
        "currect_answer": "answer_2",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: definizione",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "In un flowchart la struttura di tipo Decision rappresenta:",
        "answer_1": "Una serie di azioni eseguite in sequenza",
        "answer_2": "Una serie di azioni eseguite con un controllo decisionale (si/no)",
        "answer_3": "Una serie di azioni eseguite una o più volte",
        "answer_4": "Una serie di azioni eseguite due o tre volte",
        "currect_answer": "answer_2",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: struttura",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "In un flowchart la struttura di tipo Repetition rappresenta:",
        "answer_1": "Una serie di azioni eseguite in sequenza",
        "answer_2": "Una serie di azioni eseguite con un controllo decisionale (si/no)",
        "answer_3": "Una serie di azioni eseguite una o più volte",
        "answer_4": "Una serie di azioni eseguite due o tre volte",
        "currect_answer": "answer_3",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: struttura",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "L'azione eseguita da una struttura «repetition»:",
        "answer_1": "Non deve causare la terminazione del ciclo",
        "answer_2": "Deve sempre condurre ad un ciclo infinito",
        "answer_3": "Può condurre ad un ciclo infinito e, talvolta, è utile",
        "answer_4": "Deve causare la terminazione del ciclo altrimenti si crea un ciclo infinito",
        "currect_answer": "answer_4",
        "module": "modulo 3_1",
	    "paragraph": "Flowchart: struttura",
        "link_pdf": "programmazione_1/dispensa_3_1"
    },
    {
        "question": "La definizione ' l'insieme di regole formali per la scrittura di parole in un linguaggio ' si riferisce a:",
        "answer_1": "Lessico",
        "answer_2": "Sintassi",
        "answer_3": "Semantica",
        "answer_4": "Linguaggio",
        "currect_answer": "answer_1",
        "module": "modulo 5_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "La definizione ' l'insieme di regole formali per la scrittura di frasi in un linguaggio, che stabiliscono cioè la grammatica del linguaggio stesso ' si riferisce a:",
        "answer_1": "Lessico",
        "answer_2": "Sintassi",
        "answer_3": "Semantica",
        "answer_4": "Linguaggio",
        "currect_answer": "answer_2",
        "module": "modulo 5_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "La definizione ' l'insieme dei significati da attribuire alle frasi (sintatticamente corrette) costruite nel linguaggio ' si riferisce a:",
        "answer_1": "Lessico",
        "answer_2": "Sintassi",
        "answer_3": "Semantica",
        "answer_4": "Linguaggio",
        "currect_answer": "answer_3",
        "module": "modulo 5_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "Il calcolatore comprende solo:",
        "answer_1": "Linguaggi ad alto livello",
        "answer_2": "Lingua inglese",
        "answer_3": "Lingua italiana",
        "answer_4": "Linguaggio binario",
        "currect_answer": "answer_4",
        "module": "modulo 5_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "La programmazione a basso livello consente di sviluppare programmi molto efficienti su uno specifico sistema hardware/software, ed è:",
        "answer_1": "Semplice e comprensibile",
        "answer_2": "Ardua e poco intuitiva",
        "answer_3": "Semplice ma poco intuitiva",
        "answer_4": "Ardua ma facilmente comprensibile",
        "currect_answer": "answer_2",
        "module": "modulo 5_1",
	    "paragraph": "Linguaggi di programmazione",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "Consentono di trattare oggetti complessi senza doversi preoccupare dei dettagli della macchina sulla quale il programma viene eseguito…",
        "answer_1": "Linguaggi a basso livello",
        "answer_2": "Linguaggi ad alto livello",
        "answer_3": "Sia i linguaggi ad alto livello che quelli a basso livello",
        "answer_4": "Linguaggi assembly",
        "currect_answer": "answer_2",
        "module": "modulo 5_1",
	    "paragraph": "I linguaggi ad alto livello",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "'Facilità nell'effettuare modifiche di tipo correttivo, perfettivo, evolutivo e adattivo'. Ci riferiamo a:",
        "answer_1": "Portabilità",
        "answer_2": "Leggibilità",
        "answer_3": "Manutenibilità",
        "answer_4": "Compilazione",
        "currect_answer": "answer_3",
        "module": "modulo 5_1",
	    "paragraph": "I linguaggi ad alto livello",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "'I programmi scritti per un calcolatore possono essere utilizzati su qualsiasi altro calcolatore, previa ricompilazione'. Ci riferiamo a:",
        "answer_1": "Portabilità",
        "answer_2": "Leggibilità",
        "answer_3": "Manutenibilità",
        "answer_4": "Compilazione",
        "currect_answer": "answer_1",
        "module": "modulo 5_1",
	    "paragraph": "I linguaggi ad alto livello",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "'La relativa similitudine con i linguaggi naturali rende i programmi più semplici, non solo da scrivere, ma anche da leggere'. Ci riferiamo a:",
        "answer_1": "Portabilità",
        "answer_2": "Leggibilità",
        "answer_3": "Manutenibilità",
        "answer_4": "Compilazione",
        "currect_answer": "answer_2",
        "module": "modulo 5_1",
	    "paragraph": "I linguaggi ad alto livello",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "Il modello computazionale è basato sul cambiamento di stato della memoria della macchina...",
        "answer_1": "Nei linguaggi dichiarativi",
        "answer_2": "Sia nei linguaggi dichiarativi che imperativi",
        "answer_3": "Nei linguaggi imperativi",
        "answer_4": "Nei linguaggi dichiarativi o nei linguaggi imperativi, a seconda dei casi",
        "currect_answer": "answer_3",
        "module": "modulo 5_1",
	    "paragraph": "Tipi di linguaggi ad alto livello",
        "link_pdf": "programmazione_1/dispensa_5_1"
    },
    {
        "question": "ANSI C nasce nel:",
        "answer_1": "1978",
        "answer_2": "1980",
        "answer_3": "1989",
        "answer_4": "1990",
        "currect_answer": "answer_3",
        "module": "modulo 1",
	    "paragraph": "Storia e versioni",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Il linguaggio C:",
        "answer_1": "Ha solo caratteristiche di alto livello",
        "answer_2": "Ha solo caratteristiche di basso livello",
        "answer_3": "Ha sia caratteristiche di alto che di basso livello",
        "answer_4": "Non ha caratteristiche di alto e basso livello",
        "currect_answer": "answer_3",
        "module": "modulo 1",
	    "paragraph": "Storia e versioni",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "I tipi di errore Error e Warning…",
        "answer_1": "Sono la stessa cosa",
        "answer_2": "Sono due cose diverse",
        "answer_3": "Non appartengono al linguaggio C",
        "answer_4": "Appartengono solo alle prime versioni del linguaggio C",
        "currect_answer": "answer_2",
        "module": "modulo 1",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Nel linguaggio C, i caratteri maiuscoli e minuscoli:",
        "answer_1": "Sono la stessa cosa perché il linguaggio C è 'case sensitive'",
        "answer_2": "Non si possono usare",
        "answer_3": "Sono uguali o diversi a seconda del blocco di istruzioni",
        "answer_4": "Sono considerati diversi perché il linguaggio C è 'case sensitive'",
        "currect_answer": "answer_4",
        "module": "modulo 1",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Quando una istruzione è costituita dal solo carattere ';':",
        "answer_1": "E' considerata istruzione nulla",
        "answer_2": "E' equivalente ad una inizializzazione",
        "answer_3": "E' un commento",
        "answer_4": "Viene segnalato un Error",
        "currect_answer": "answer_1",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "L'inizio di un commento è caratterizzato dalla coppia di caratteri:",
        "answer_1": "*/",
        "answer_2": "/*",
        "answer_3": "**",
        "answer_4": "/**",
        "currect_answer": "answer_2",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Un blocco di codice è un insieme di istruzioni racchiuso tra parentesi:",
        "answer_1": "Tonde",
        "answer_2": "Quadre",
        "answer_3": "Angolari",
        "answer_4": "Graffe",
        "currect_answer": "answer_4",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Se il blocco di codice è costituito da una sola istruzione:",
        "answer_1": "Si usano parentesi tonde al posto delle parentesi graffe",
        "answer_2": "Le parentesi graffe vengono normalmente omesse",
        "answer_3": "Si usano parentesi quadre al posto delle parentesi graffe",
        "answer_4": "Si usa doppia parentesi graffa",
        "currect_answer": "answer_2",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "L'indentazione è utile per:",
        "answer_1": "Comprendere meglio il flusso del programma",
        "answer_2": "Eseguire il codice più velocemente",
        "answer_3": "Occupare meno spazio in memoria",
        "answer_4": "Ottenere un eseguibile in automatico",
        "currect_answer": "answer_1",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Le istruzioni in un programma C terminano sempre con…",
        "answer_1": ";",
        "answer_2": "::",
        "answer_3": ";;",
        "answer_4": "()",
        "currect_answer": "answer_1",
        "module": "modulo 1",
	    "paragraph": "Sintassi",
        "link_pdf": "programmazione_1/dispensa_1"
    },
    {
        "question": "Le direttive come #include, #define vengono elaborati da:",
        "answer_1": "Compilatore",
        "answer_2": "Linker",
        "answer_3": "Preprocessore",
        "answer_4": "Linker e compilatore",
        "currect_answer": "answer_3",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Traduce il codice C in linguaggio macchina…",
        "answer_1": "Compilatore",
        "answer_2": "Linker",
        "answer_3": "Preprocessore",
        "answer_4": "Linker e compilatore",
        "currect_answer": "answer_1",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "I tipi di errore Error e Warning…",
        "answer_1": "Sono la stessa cosa",
        "answer_2": "Sono due cose diverse",
        "answer_3": "Non appartengono al linguaggio C",
        "answer_4": "Appartengono solo alle prime versioni del linguaggio C",
        "currect_answer": "answer_2",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Nel linguaggio C, i caratteri maiuscoli e minuscoli:",
        "answer_1": "Sono la stessa cosa perché il linguaggio C è 'case sensitive'",
        "answer_2": "Non si possono usare",
        "answer_3": "Sono uguali o diversi a seconda del blocco di istruzioni",
        "answer_4": "Sono considerati diversi perché il linguaggio C è 'case sensitive'",
        "currect_answer": "answer_4",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Se decidiamo di scrivere un programma con un qualsiasi editor di testo, per poter vedere il risultato dobbiamo salvare il file con estensione:",
        "answer_1": ".txt",
        "answer_2": ".doc",
        "answer_3": ".c",
        "answer_4": ".xls",
        "currect_answer": "answer_3",
        "module": "modulo 2",
	    "paragraph": "Compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "L'assembler è incaricato di creare il codice oggetto salvandolo in un file…",
        "answer_1": ".a sotto Unix/Linux e .c in Dos/Windows",
        "answer_2": ".c sotto Unix/Linux e .obj in Dos/Windows",
        "answer_3": ".o sia sotto Unix/Linux che sotto Dos/Windows",
        "answer_4": ".o sotto Unix/Linux e .obj in Dos/Windows",
        "currect_answer": "answer_4",
        "module": "modulo 2",
	    "paragraph": "Compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "GCC è un:",
        "answer_1": "Editor di testo",
        "answer_2": "Ambiente di sviluppo completo",
        "answer_3": "Compilatore",
        "answer_4": "Linguaggio di programmazione",
        "currect_answer": "answer_3",
        "module": "modulo 2",
	    "paragraph": "Compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Assembla in un unico file eseguibile i file oggetto prodotti da diversi file sorgente e le librerie:",
        "answer_1": "Compilatore",
        "answer_2": "Linker",
        "answer_3": "Preprocessore",
        "answer_4": "Linker e compilatore",
        "currect_answer": "answer_2",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Sono errori sintattici, che impediscono la generazione del codice eseguibile:",
        "answer_1": "Warning",
        "answer_2": "Error",
        "answer_3": "Sia Error che Warning",
        "answer_4": "Warning nella maggior parte dei casi",
        "currect_answer": "answer_2",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Sono errori non sintattici che non impediscono la generazione del codice eseguibile:",
        "answer_1": "Warning",
        "answer_2": "Error",
        "answer_3": "Sia Error che Warning",
        "answer_4": "Warning nella maggior parte dei casi",
        "currect_answer": "answer_1",
        "module": "modulo 2",
	    "paragraph": "Fasi di compilazione",
        "link_pdf": "programmazione_1/dispensa_2"
    },
    {
        "question": "Una riga di commento inizia con:",
        "answer_1": "\\",
        "answer_2": "//",
        "answer_3": "**",
        "answer_4": "/?",
        "currect_answer": "answer_2",
        "module": "modulo 3",
	    "paragraph": "Struttura del Programma",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Un commento multilinea termina con:",
        "answer_1": "\\",
        "answer_2": "//",
        "answer_3": "*/",
        "answer_4": "/*",
        "currect_answer": "answer_3",
        "module": "modulo 3",
	    "paragraph": "Struttura del Programma",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Le istruzioni di include per il preprocessore iniziano con:",
        "answer_1": "#",
        "answer_2": "\"",
        "answer_3": "*/",
        "answer_4": "(",
        "currect_answer": "answer_1",
        "module": "modulo 3",
	    "paragraph": "Struttura del Programma",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Un blocco e' racchiuso da parentesi",
        "answer_1": "graffe",
        "answer_2": "tonde",
        "answer_3": "quadrate",
        "answer_4": "angolari",
        "currect_answer": "answer_1",
        "module": "modulo 3",
	    "paragraph": "La funzione main",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Il termine void, argomento della funzione main, e' racchiuso fra parentesi:",
        "answer_1": "graffe",
        "answer_2": "tonde",
        "answer_3": "quadrate",
        "answer_4": "angolari",
        "currect_answer": "answer_2",
        "module": "modulo 3",
	    "paragraph": "La funzione main",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Il messaggio da stampare all'interno della funzione printf va racchiuso fra:",
        "answer_1": "\"",
        "answer_2": "\\",
        "answer_3": "[",
        "answer_4": "[",
        "currect_answer": "answer_",
        "module": "modulo 3",
	    "paragraph": "La funzione printf",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Ogni istruzione deve terminare con:",
        "answer_1": "punto",
        "answer_2": "virgola",
        "answer_3": "due punti",
        "answer_4": "punto e virgola",
        "currect_answer": "answer_4",
        "module": "modulo 3",
	    "paragraph": "La funzione printf",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "La sequenza di escape \\n:",
        "answer_1": "posiziona il cursore alla riga successiva",
        "answer_2": "produce un suono o un allarme",
        "answer_3": "inserisce un carattere di backslash",
        "answer_4": "Inserisce un carattere di backslash seguito dalla lettera n",
        "currect_answer": "answer_1",
        "module": "modulo 3",
	    "paragraph": "La funzione printf",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "La sequenza di escape \\a:",
        "answer_1": "posiziona il cursore alla riga successiva",
        "answer_2": "produce un suono o un allarme",
        "answer_3": "inserisce un carattere di backslash",
        "answer_4": "inserisce un carattere di backslash seguito dalla lettera a",
        "currect_answer": "answer_2",
        "module": "modulo 3",
	    "paragraph": "La funzione printf",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "stdio.h contiene:",
        "answer_1": "l'istruzione main",
        "answer_2": "il linker",
        "answer_3": "l'eseguibile",
        "answer_4": "l'istruzione printf",
        "currect_answer": "answer_4",
        "module": "modulo 3",
	    "paragraph": "La funzione printf",
        "link_pdf": "programmazione_1/dispensa_3"
    },
    {
        "question": "Chiedere un numero all'utente è una operazione di:",
        "answer_1": "input",
        "answer_2": "output",
        "answer_3": "elaborazione",
        "answer_4": "input e output",
        "currect_answer": "answer_1",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "Le variabili devono essere:",
        "answer_1": "definite con un nome e un tipo di dato",
        "answer_2": "definite con il solo nome",
        "answer_3": "definite in un punto qualsiasi del programma",
        "answer_4": "usate prima della definizione",
        "currect_answer": "answer_1",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "Il nome di una variabile:",
        "answer_1": "è a discrezione del compilatore",
        "answer_2": "deve includere trattini \"_\"",
        "answer_3": "è sensibile all'uso del carattere",
        "answer_4": "inizia con una cifra",
        "currect_answer": "answer_3",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "La funzione scanf:",
        "answer_1": "scrive sullo standard output",
        "answer_2": "include stringhe di controllo di formato",
        "answer_3": "puo' essere priva di argomenti",
        "answer_4": "stampa sullo schermo un messaggio",
        "currect_answer": "answer_2",
        "module": "modulo 4",
	    "paragraph": "Funzione di input: scanf",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "Nella funzione scanf, una variabile deve essere:",
        "answer_1": "preceduta da &",
        "answer_2": "seguita da &",
        "answer_3": "preceduta da %",
        "answer_4": "seguita da %",
        "currect_answer": "answer_1",
        "module": "modulo 4",
	    "paragraph": "Funzione di input: scanf",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "La stringa di controllo di formato per un integer include la lettera:",
        "answer_1": "f",
        "answer_2": "d",
        "answer_3": "i",
        "answer_4": "p",
        "currect_answer": "answer_2",
        "module": "modulo 4",
	    "paragraph": "Funzione di input: scanf",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "L'operatore di assegnazione è:",
        "answer_1": "%",
        "answer_2": "\"",
        "answer_3": "==",
        "answer_4": "=",
        "currect_answer": "answer_4",
        "module": "modulo 4",
	    "paragraph": "Funzione di input: scanf",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "In C, i calcoli possono essere eseguiti:",
        "answer_1": "nell'istruzione printf, all'esterno di virgolette \" \"",
        "answer_2": "a sinistra dell'operatore di assegnazione",
        "answer_3": "nell'istruzione scanf, all'interno di virgolette \" \"",
        "answer_4": "nell'istruzione printf, all'interno di virgolette \" \"",
        "currect_answer": "answer_1",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "È possibile assegnare un valore a una variabile:",
        "answer_1": "nella sua definizione",
        "answer_2": "prima delle istruzioni al preprocessore",
        "answer_3": "senza terminare l'istruzione con il punto e virgola",
        "answer_4": "solo se diverso da zero",
        "currect_answer": "answer_1",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "l'istruzione: int a1, a2; è:",
        "answer_1": "errata, non si possono definire due variabili nella stessa istruzione",
        "answer_2": "errata, non si possono dichiarare variabili con nome a1 e a2.",
        "answer_3": "corretta",
        "answer_4": "errata, non si possono separare due variabili con virgola",
        "currect_answer": "answer_3",
        "module": "modulo 4",
	    "paragraph": "Le variabili",
        "link_pdf": "programmazione_1/dispensa_4"
    },
    {
        "question": "L'istruzione scanf( '%d', &var ); :",
        "answer_1": "sovrascrive la locazione di memoria di var",
        "answer_2": "legge la locazione di memoria di var",
        "answer_3": "scrive nella locazione di memoria di var solo se vuota",
        "answer_4": "stampa il contenuto della locazione di memoria",
        "currect_answer": "answer_1",
        "module": "modulo 5",
	    "paragraph": "Concetti relativi alla memoria",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "L'istruzione a = b; è:",
        "answer_1": "distruttiva per la variabile a",
        "answer_2": "non distruttiva per la variabile a",
        "answer_3": "distruttiva per la variabile b",
        "answer_4": "non distruttiva per le variabili a e b",
        "currect_answer": "answer_1",
        "module": "modulo 5",
	    "paragraph": "Concetti relativi alla memoria",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "Il segno di percentuale (%) indica l'operatore di:",
        "answer_1": "modulo",
        "answer_2": "esponente",
        "answer_3": "resto",
        "answer_4": "decimale",
        "currect_answer": "answer_3",
        "module": "modulo 5",
	    "paragraph": "Operatori aritmetici",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "La divisione intera 22 / 3 restituisce:",
        "answer_1": "7",
        "answer_2": "1",
        "answer_3": "7,333",
        "answer_4": "3",
        "currect_answer": "answer_1",
        "module": "modulo 5",
	    "paragraph": "Operatori aritmetici",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "Gli operatori del C sono calcolati:",
        "answer_1": "da sinistra a destra",
        "answer_2": "da destra a sinistra",
        "answer_3": "a seconda della loro associatività",
        "answer_4": "in ordine di definizione",
        "currect_answer": "answer_3",
        "module": "modulo 5",
	    "paragraph": "Operatori aritmetici",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "I calcoli sono normalmente eseguiti da istruzioni di:",
        "answer_1": "assegnazione",
        "answer_2": "definizione",
        "answer_3": "operandi",
        "answer_4": "controllo",
        "currect_answer": "answer_1",
        "module": "modulo 5",
	    "paragraph": "Operatori aritmetici",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "Il valore dell'istruzione x = 33 - 3 * ( 3 + 3 * ( 3 ) / 3 - 3)); corrisponde a:",
        "answer_1": "27",
        "answer_2": "errore per parentesi ridondanti",
        "answer_3": "24",
        "answer_4": "90",
        "currect_answer": "answer_2",
        "module": "modulo 5",
	    "paragraph": "Espressioni algebriche",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "Le regole di precedenza indicano che:",
        "answer_1": "operatore di moltiplicazione ha la precedenza su operatore di resto",
        "answer_2": "operatore di resto ha la precedenza su operatore di moltiplicazione",
        "answer_3": "moltiplicazione ha la precedenza sulle operazioni all'interno di parentesi annidate",
        "answer_4": "l'operatore di resto ha la precedenza sull'uguale",
        "currect_answer": "answer_4",
        "module": "modulo 5",
	    "paragraph": "Espressioni algebriche",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "In caso di parentesi annidate:",
        "answer_1": "gli operatori nella coppia di parentesi più interne sono applicati per primi",
        "answer_2": "gli operatori nella coppia di parentesi più interne sono applicati per ultimi",
        "answer_3": "gli operatori di moltiplicazione sono applicati per primi",
        "answer_4": "gli operatori di somma sono applicati per primi",
        "currect_answer": "answer_1",
        "module": "modulo 5",
	    "paragraph": "Espressioni algebriche",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "Per scrivere su una stessa linea i valori 5 e 2 si usa:",
        "answer_1": "printf( '10/2, 2\\n' );",
        "answer_2": "scanf( '%d%d\\n', 10/2, 2 );",
        "answer_3": "x=10/5; printf('5, %d\\n', &x);",
        "answer_4": "printf('%d,%d\\n', 10/2, 10/5);",
        "currect_answer": "answer_4",
        "module": "modulo 5",
	    "paragraph": "Espressioni algebriche",
        "link_pdf": "programmazione_1/dispensa_5"
    },
    {
        "question": "L'operatore diverso si indica in C con:",
        "answer_1": "!=",
        "answer_2": "< >",
        "answer_3": "==",
        "answer_4": "not",
        "currect_answer": "answer_1",
        "module": "modulo 7",
	    "paragraph": "Operatori relazionali e di uguaglianza",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "L'operatore minore o uguale si indica in C con:",
        "answer_1": "< <",
        "answer_2": "< =",
        "answer_3": "= <",
        "answer_4": "≤",
        "currect_answer": "answer_2",
        "module": "modulo 7",
	    "paragraph": "Operatori relazionali e di uguaglianza",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "L'operatore di uguaglianza si indica in C con:",
        "answer_1": "=",
        "answer_2": "==",
        "answer_3": ":=",
        "answer_4": "=:",
        "currect_answer": "answer_2",
        "module": "modulo 7",
	    "paragraph": "Operatori relazionali e di uguaglianza",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "Gli operatori relazionali:",
        "answer_1": "hanno un livello di precedenza più alto degli operatori di uguaglianza",
        "answer_2": "hanno un livello di precedenza più basso degli operatori di uguaglianza",
        "answer_3": "hanno un livello di precedenza uguale agli operatori di assegnazione",
        "answer_4": "hanno un livello di precedenza uguale agli operatori di uguaglianza",
        "currect_answer": "answer_1",
        "module": "modulo 7",
	    "paragraph": "Operatori relazionali e di uguaglianza",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "Migliora la leggibilità del programma:",
        "answer_1": "eliminare righe vuote sopra l'istruzione if",
        "answer_2": "eliminare righe vuote sotto l'istruzione if",
        "answer_3": "indentare la parentesi graffa di fine istruzione if",
        "answer_4": "indentare il corpo di ognuna delle istruzioni if",
        "currect_answer": "answer_4",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "Nel corpo di un'istruzione if:",
        "answer_1": "è corretto spezzare gli identificatori",
        "answer_2": "si devono evitare le parentesi graffe se è inserita una sola istruzione",
        "answer_3": "si può inserire un numero qualsiasi di istruzioni",
        "answer_4": "si può inserire una sola istruzione di assegnazione",
        "currect_answer": "answer_3",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "L'associatività da destra a sinistra si ha per l'operatore:",
        "answer_1": "()",
        "answer_2": "*",
        "answer_3": "=",
        "answer_4": ":=",
        "currect_answer": "answer_3",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "L'istruzione puts:",
        "answer_1": "equivale a printf",
        "answer_2": "equivale a scanf",
        "answer_3": "stampa testo e determina un ritorno a capo",
        "answer_4": "migliora la sicurezza per istruzioni di output con argomenti multipli",
        "currect_answer": "answer_3",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "L'istruzione printf( '%s', 'Welcome' ); è:",
        "answer_1": "stampa Welcome e non va a capo",
        "answer_2": "stampa Welcome e va a capo",
        "answer_3": "errata a causa dell'uso di %s",
        "answer_4": "errata a causa della mancanza di /n",
        "currect_answer": "answer_1",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "Le parole chiave:",
        "answer_1": "sono usate per istruzioni di ricerca in locazioni di memoria",
        "answer_2": "non devono essere usate come nomi delle variabili",
        "answer_3": "includono printf e scanf",
        "answer_4": "non devono essere usate nei programmi C",
        "currect_answer": "answer_2",
        "module": "modulo 7",
	    "paragraph": "Istruzione if",
        "link_pdf": "programmazione_1/dispensa_7"
    },
    {
        "question": "Una procedura per risolvere un problema che consta in un insieme di azioni da eseguire e in un dato ordine in cui esse vanno eseguite è chiamata:",
        "answer_1": "programmazione strutturata",
        "answer_2": "algoritmo",
        "answer_3": "struttura sequenziale strutturata",
        "answer_4": "struttura di controllo",
        "currect_answer": "answer_2",
        "module": "modulo 8",
	    "paragraph": "Pseudocodice",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Lo pseudocodice è costituito solamente da:",
        "answer_1": "istruzioni di decisione e azione",
        "answer_2": "istruzioni in linguaggio C",
        "answer_3": "azioni sequenziali",
        "answer_4": "da dichiarazioni di variabili",
        "currect_answer": "answer_1",
        "module": "modulo 8",
	    "paragraph": "Pseudocodice",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "I programmi in pseudocodice:",
        "answer_1": "sono eseguiti dal preprocessore",
        "answer_2": "sono eseguiti dal compilatore",
        "answer_3": "non sono eseguiti al computer",
        "answer_4": "sono compilati dal linker",
        "currect_answer": "answer_3",
        "module": "modulo 8",
	    "paragraph": "Pseudocodice",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Un diagramma di flusso è:",
        "answer_1": "una rappresentazione in linguaggio formale di un algoritmo",
        "answer_2": "una rappresentazione grafica di un algoritmo",
        "answer_3": "una rappresentazione matematica di un algoritmo",
        "answer_4": "una rappresentazione in pseudocodice di un algoritmo",
        "currect_answer": "answer_2",
        "module": "modulo 8",
	    "paragraph": "Diagrammi di flusso",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Nei diagrammi di flusso, porzioni omesse vengono rappresentate da:",
        "answer_1": "linee di flusso",
        "answer_2": "rettangoli arrotondati",
        "answer_3": "rettangoli",
        "answer_4": "cerchietti",
        "currect_answer": "answer_4",
        "module": "modulo 8",
	    "paragraph": "Diagrammi di flusso",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Nei diagrammi di flusso, il simbolo di decisione è rappresentato da:",
        "answer_1": "un rombo con due linee di flusso che emergono da esso",
        "answer_2": "un rombo con una sola linea di flusso in uscita",
        "answer_3": "un rettangolo con due linee di flusso che emergono da esso",
        "answer_4": "un rettangolo arrotondato con due linee di flusso che emergono da esso",
        "currect_answer": "answer_1",
        "module": "modulo 8",
	    "paragraph": "Diagrammi di flusso",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Se l'istruzione successiva da eseguire può essere diversa dalla successiva in sequenza si parla di esecuzione con:",
        "answer_1": "trasferimento del controllo",
        "answer_2": "strutture di controllo sequenziale",
        "answer_3": "strutture di controllo iterative",
        "answer_4": "strutture di controllo di selezione",
        "currect_answer": "answer_1",
        "module": "modulo 8",
	    "paragraph": "Strutture di controllo",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "L'istruzione di selezione singola è:",
        "answer_1": "if",
        "answer_2": "if...else",
        "answer_3": "switch",
        "answer_4": "while",
        "currect_answer": "answer_1",
        "module": "modulo 8",
	    "paragraph": "Strutture di controllo",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "La struttura di iterazione consente di eseguire azioni finché:",
        "answer_1": "non si incontra una istruzione di selezione",
        "answer_2": "non si incontra una istruzione di sequenza",
        "answer_3": "non si incontra una istruzione di iterazione",
        "answer_4": "non si soddisfano determinate condizioni",
        "currect_answer": "answer_4",
        "module": "modulo 8",
	    "paragraph": "Strutture di controllo",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Le decisioni nell'istruzione if:",
        "answer_1": "devono basarsi su espressioni che abbiano valore zero",
        "answer_2": "possono basarsi su qualsiasi espressione",
        "answer_3": "devono basarsi su condizioni contenenti il >=",
        "answer_4": "devono basarsi su condizioni contenenti ==",
        "currect_answer": "answer_2",
        "module": "modulo 8",
	    "paragraph": "Strutture di controllo",
        "link_pdf": "programmazione_1/dispensa_8"
    },
    {
        "question": "Nell'istruzione if...else, se la condizione nell'if è vera:",
        "answer_1": "vengono eseguite entrambe le azioni nell'if e nell'else",
        "answer_2": "viene eseguita solo l'azione nell'else",
        "answer_3": "non viene eseguita l'azione nell'else",
        "answer_4": "non viene eseguita alcuna azione",
        "currect_answer": "answer_3",
        "module": "modulo 9",
	    "paragraph": "Istruzione if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "Il corpo di else:",
        "answer_1": "richiede sempre parentesi graffe",
        "answer_2": "richiede sempre parentesi tonde",
        "answer_3": "non richiede sempre parentesi graffe",
        "answer_4": "richiede sempre parentesi angolari",
        "currect_answer": "answer_3",
        "module": "modulo 9",
	    "paragraph": "Istruzione if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "L'operatore condizionale si indica con:",
        "answer_1": ":?",
        "answer_2": "?",
        "answer_3": ":=",
        "answer_4": "?:",
        "currect_answer": "answer_4",
        "module": "modulo 9",
	    "paragraph": "Operatore condizionale ?:",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "Nell'espressione condizionale, con operatore condizionale, il secondo operando è:",
        "answer_1": "l'espressione se la condizione è falsa",
        "answer_2": "l'espressione se la condizione è vera",
        "answer_3": "la condizione",
        "answer_4": "privo di significato",
        "currect_answer": "answer_2",
        "module": "modulo 9",
	    "paragraph": "Operatore condizionale ?:",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "In questa istruzione var > 10 ? puts( 'Lost' ) ?: puts( 'Win' ); sono presenti:",
        "answer_1": "0 errori",
        "answer_2": "1 errore",
        "answer_3": "2 errori",
        "answer_4": "3 errori",
        "currect_answer": "answer_2",
        "module": "modulo 9",
	    "paragraph": "Operatore condizionale ?:",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "In questa istruzione var > 10 ? puts( 'Lost' ); : puts( 'Win' ); sono presenti:",
        "answer_1": "0 errori",
        "answer_2": "1 errore",
        "answer_3": "2 errori",
        "answer_4": "3 errori",
        "currect_answer": "answer_2",
        "module": "modulo 9",
	    "paragraph": "Operatore condizionale ?:",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "Nelle istruzioni annidate if...else:",
        "answer_1": "tutte le condizioni vere vengono eseguite",
        "answer_2": "solo l'ultima condizione vera viene eseguita",
        "answer_3": "solo la prima condizione vera viene eseguita",
        "answer_4": "nessuna condizione vera viene eseguita",
        "currect_answer": "answer_3",
        "module": "modulo 9",
	    "paragraph": "Istruzioni annidate if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "La riga di codice else if ( x >= 24 ); {x++;} conteine:",
        "answer_1": "0 errori",
        "answer_2": "1 errore",
        "answer_3": "2 errori",
        "answer_4": "3 errori",
        "currect_answer": "answer_2",
        "module": "modulo 9",
	    "paragraph": "Istruzioni annidate if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "Un errore di sintassi:",
        "answer_1": "è individuato dal compilatore",
        "answer_2": "all'esecuzione fa sì che il programma fallisca",
        "answer_3": "all'esecuzione fa sì che il programma termini prematuramente",
        "answer_4": "all'esecuzione produce risultati non corretti",
        "currect_answer": "answer_1",
        "module": "modulo 9",
	    "paragraph": "Istruzioni annidate if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "L'istruzione vuota è rappresentata da:",
        "answer_1": ";",
        "answer_2": ":",
        "answer_3": "()",
        "answer_4": "[]",
        "currect_answer": "answer_1",
        "module": "modulo 9",
	    "paragraph": "Istruzioni annidate if...else",
        "link_pdf": "programmazione_1/dispensa_9"
    },
    {
        "question": "L'istruzione while:",
        "answer_1": "è una istruzione di definizione",
        "answer_2": "è una istruzione di iterazione",
        "answer_3": "è una istruzione di dichiarazione",
        "answer_4": "è una istruzione di assegnamento",
        "currect_answer": "answer_2",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Il ciclo while termina:",
        "answer_1": "quando la condizione diventa falsa",
        "answer_2": "quando la condizione diventa vera",
        "answer_3": "mai",
        "answer_4": "solo in caso errore",
        "currect_answer": "answer_1",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Il corpo dell'istruzione while:",
        "answer_1": "deve essere un'istruzione singola",
        "answer_2": "deve essere un'istruzione composta",
        "answer_3": "non deve contenere istruzioni",
        "answer_4": "può essere un'istruzione singola o un'istruzione composta",
        "currect_answer": "answer_4",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Quando l'iterazione while termina:",
        "answer_1": "viene eseguita l'iterazione un'ultima volta",
        "answer_2": "viene eseguita la prima istruzione dopo la struttura di iterazione",
        "answer_3": "termina il programma",
        "answer_4": "viene eseguita l'ultima istruzione prima della struttura di iterazione",
        "currect_answer": "answer_2",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Il diagramma di flusso dell'iterazione while si compone di:",
        "answer_1": "un rombo e di un rettangolo sull'uscita vera",
        "answer_2": "un rettangolo seguito sequenzialmente da un rombo",
        "answer_3": "un rombo seguito sequenzialmente da un rettangolo",
        "answer_4": "un rombo e di un rettangolo sull'uscita falsa",
        "currect_answer": "answer_1",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Dato int n=1, il programma che stampa come ultimo numero il valore 9 è:",
        "answer_1": "while ( n < 9 ) { printf('%d ', n++); }",
        "answer_2": "while ( n < 9 ) { printf('%d ', n); }",
        "answer_3": "while ( n < 18 ) { printf('%d ', n--); }",
        "answer_4": "while ( n <= 9 ) { printf('%d ', n++); }",
        "currect_answer": "answer_4",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Dato int x=0, il programma che stampa come ultimo numero il valore 7 è:",
        "answer_1": "while ( x < 7 ) {x++;} printf('%d', x);",
        "answer_2": "while ( x < 7 ) {x++;} printf('%d', ++x);",
        "answer_3": "while ( x < 7 ) {x;} printf('%d', x);",
        "answer_4": "while ( x <= 7 ) {x++;} printf('%d');",
        "currect_answer": "answer_1",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Dato int x=1; l'istruzione while (x < 9); restituisce:",
        "answer_1": "errore di compilazione",
        "answer_2": "ciclo infinito",
        "answer_3": "stampa 9",
        "answer_4": "stampa 9",
        "currect_answer": "answer_2",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Dato int x = -1; il codice while (x < 99){x++;} esegue:",
        "answer_1": "98 iterazioni",
        "answer_2": "99 iterazioni",
        "answer_3": "100 iterazioni",
        "answer_4": "101 iterazioni",
        "currect_answer": "answer_3",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "Dato int x=1; l'istruzione while (x < 1) {x++;} è:",
        "answer_1": "corretta, non esegue alcuna iterazione",
        "answer_2": "corretta, esegue due iterazioni",
        "answer_3": "corretta, esegue una iterazione",
        "answer_4": "errata",
        "currect_answer": "answer_1",
        "module": "modulo 10",
	    "paragraph": "Istruzione while",
        "link_pdf": "programmazione_1/dispensa_10"
    },
    {
        "question": "L'iterazione controllata da contatore è una iterazione:",
        "answer_1": "definita",
        "answer_2": "indefinita",
        "answer_3": "di inizializzazione",
        "answer_4": "di primo affinamento",
        "currect_answer": "answer_1",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Nell'ierazione controllata da contatore, il contatore specifica il numero:",
        "answer_1": "della variabile sentinella",
        "answer_2": "di locazioni di memoria utilizzate dall'iterazione",
        "answer_3": "di volte in cui l'istruzione printf deve essere eseguita",
        "answer_4": "di volte in cui le istruzioni dell'iterazione deveno essere eseguite",
        "currect_answer": "answer_4",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Nelle iterazioni definite, il numero di esecuzioni dell'iterazione:",
        "answer_1": "è zero",
        "answer_2": "non si conosce prima che il ciclo inizi l'esecuzione",
        "answer_3": "lo determina l'utente durante l'esecuzione",
        "answer_4": "si conosce prima che il ciclo inizi l'esecuzione",
        "currect_answer": "answer_4",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Per un contatore da 0 a 20000, la variabile piu' appropriata e' di tipo:",
        "answer_1": "int",
        "answer_2": "unsigned int",
        "answer_3": "float",
        "answer_4": "double",
        "currect_answer": "answer_2",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Se un contatore non viene inizializzato:",
        "answer_1": "si verifica un errore logico",
        "answer_2": "si verifica un errore di compilazione",
        "answer_3": "si verifica un errore al linker",
        "answer_4": "non si verificano errori",
        "currect_answer": "answer_1",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Se un contatore non viene inizializzato:",
        "answer_1": "il programma lo inizializza automaticamente a la valore 0",
        "answer_2": "il programma lo inizializza automaticamente a la valore 1",
        "answer_3": "il programma considera l'ultimo valore memorizzato nella locazione di memoria riservata per quella variabile",
        "answer_4": "l'esecuzione del programma non viene avviata",
        "currect_answer": "answer_3",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "La divisione intera 817/10 produce:",
        "answer_1": "81.7",
        "answer_2": "81,7",
        "answer_3": "81",
        "answer_4": "82",
        "currect_answer": "answer_3",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Se un contatore int viene incrementato di 1 oltre il suo limito superiore, si ottiene:",
        "answer_1": "errore di compilazione",
        "answer_2": "come successivo valore un numero negativo",
        "answer_3": "come successivo valore lo zero",
        "answer_4": "come successivo valore un numero casuale relativo alla locazione di memoria utilizzata",
        "currect_answer": "answer_2",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Se un contatore unsigned int viene incrementato di 1 oltre il suo limito superiore, si ottiene:",
        "answer_1": "errore di compilazione",
        "answer_2": "come successivo valore un numero negativo",
        "answer_3": "come successivo valore lo zero",
        "answer_4": "come successivo valore un numero casuale relativo alla locazione di memoria utilizzata",
        "currect_answer": "answer_3",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "Una buona pratica di programmazione prevede di:",
        "answer_1": "non inizializzare i contatori e i totali per evitare l'occupazione inutile di locazioni di memoria",
        "answer_2": "inizializzare solo i contatori",
        "answer_3": "inizializzare solo i totali",
        "answer_4": "inizializzare tutti i contatori e i totali",
        "currect_answer": "answer_4",
        "module": "modulo 11",
	    "paragraph": "Iterazione controllata da contatore: esempio",
        "link_pdf": "programmazione_1/dispensa_11"
    },
    {
        "question": "L'iterazione controllata da sentinella è una iterazione:",
        "answer_1": "definita",
        "answer_2": "indefinita",
        "answer_3": "di inizializzazione",
        "answer_4": "di primo affinamento",
        "currect_answer": "answer_2",
        "module": "modulo 12",
	    "paragraph": "Iterazione controllata da sentinella: pseudocodice",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Il valore sentinella viene utilizzato per indicare:",
        "answer_1": "che è stato inserito l'ultimo valore dell'iterazione",
        "answer_2": "che è stato inserito il primo valore dell'iterazione",
        "answer_3": "che è stato raggiunto il valore massimo del contatore",
        "answer_4": "che è stato inizializzato il contatore",
        "currect_answer": "answer_1",
        "module": "modulo 12",
	    "paragraph": "Iterazione controllata da sentinella: pseudocodice",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Nelle iterazioni indefinite, il numero di esecuzioni dell'iterazione:",
        "answer_1": "è zero",
        "answer_2": "non si conosce prima che il ciclo inizi l'esecuzione",
        "answer_3": "è uno",
        "answer_4": "si conosce prima che il ciclo inizi l'esecuzione",
        "currect_answer": "answer_2",
        "module": "modulo 12",
	    "paragraph": "Iterazione controllata da sentinella: pseudocodice",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Per un'iterazione che acquisisce l'età dei componenti di una famiglia, il valore sentinella appropriato è:",
        "answer_1": "0.5",
        "answer_2": "-1",
        "answer_3": "100",
        "answer_4": "1",
        "currect_answer": "answer_2",
        "module": "modulo 12",
	    "paragraph": "Iterazione controllata da sentinella: pseudocodice",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "L'affinamento graduale top-down:",
        "answer_1": "è una tecnica utile allo sviluppo di programmi ben strutturati",
        "answer_2": "è una tecnica utile allo sviluppo di programmi non strutturati",
        "answer_3": "è un set di istruzioni C di tipo top-down",
        "answer_4": "è un set di definizioni C di tipo top-down",
        "currect_answer": "answer_1",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "A livello top, nell'affinamento graduale top-down, si ha:",
        "answer_1": "un set di tre istruzioni di codice C",
        "answer_2": "un set di tre istruzioni di pseudocodice",
        "answer_3": "un'istruzione singola di codice C",
        "answer_4": "un'istruzione singola di pseudocodice",
        "currect_answer": "answer_4",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "A livello top, nell'affinamento graduale top-down, si definisce:",
        "answer_1": "la definizione delle variabili del programma",
        "answer_2": "la funzione iniziale del programma",
        "answer_3": "la funzione complessiva del programma",
        "answer_4": "la computazione del risultato del programma",
        "currect_answer": "answer_3",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Il processo di affinamento graduale top-down termina quando:",
        "answer_1": "lo pseudocodice definisce il programma con sufficiente dettaglio",
        "answer_2": "il codice C definisce il programma con sufficiente dettaglio",
        "answer_3": "lo pseudocodice raggiunge le dieci righe",
        "answer_4": "il codice C non da errori di compilazione",
        "currect_answer": "answer_1",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Un tentativo di dividere per zero provoca:",
        "answer_1": "la stampa di un messaggio di buffer overlow",
        "answer_2": "un warning",
        "answer_3": "un errore logico",
        "answer_4": "un errore irreversibile",
        "currect_answer": "answer_4",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "Molti programmi possono essere divisi logicamente nelle seguenti fasi:",
        "answer_1": "inizializzazione, elaborazione e chiusura",
        "answer_2": "elaborazione e chiusura",
        "answer_3": "inizializzazione, elaborazione, chiusura e ottimizzazione",
        "answer_4": "inizializzazione ed elaborazione",
        "currect_answer": "answer_1",
        "module": "modulo 12",
	    "paragraph": "Affinamento graduale top-down",
        "link_pdf": "programmazione_1/dispensa_12"
    },
    {
        "question": "In a = (float) b / c viene creata:",
        "answer_1": "una copia permanente in virgola mobile di b",
        "answer_2": "una copia temporanea in virgola mobile di b",
        "answer_3": "una copia permanente in virgola mobile di a",
        "answer_4": "una copia temporanea in virgola mobile di a",
        "currect_answer": "answer_2",
        "module": "modulo 14",
	    "paragraph": "Float e conversioni fra tipi",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'operatore cast realizza una:",
        "answer_1": "conversione esplicita di tipo di variabile",
        "answer_2": "conversione implicita di tipo di variabile",
        "answer_3": "conversione esplicita di preincremento",
        "answer_4": "conversione esplicita di preincremento",
        "currect_answer": "answer_1",
        "module": "modulo 14",
	    "paragraph": "Float e conversioni fra tipi",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'struzione printf( '%f', 10/3 ); restituisce:",
        "answer_1": "3.34",
        "answer_2": "3.33",
        "answer_3": "3.333333",
        "answer_4": "3",
        "currect_answer": "answer_3",
        "module": "modulo 14",
	    "paragraph": "Float e conversioni fra tipi",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'struzione printf( '%.2f', 5/3 ); restituisce:",
        "answer_1": "errore",
        "answer_2": "1.66",
        "answer_3": "1.666666",
        "answer_4": "1.67",
        "currect_answer": "answer_4",
        "module": "modulo 14",
	    "paragraph": "Float e conversioni fra tipi",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "Eseguendo l'istruzione scanf( '%.2f', &a ); si ottiene:",
        "answer_1": "l'acquisizione della variabile a come float con due cifre decimali",
        "answer_2": "l'acquisizione della variabile a con sei cifre decimali",
        "answer_3": "la stampa della variabile a come float con due cifre decimali",
        "answer_4": "errore",
        "currect_answer": "answer_4",
        "module": "modulo 14",
	    "paragraph": "Operatori di assegnazione, incremento e decremento",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'struzione printf( '%d', c++ ); stampa:",
        "answer_1": "il valore di c",
        "answer_2": "il valore di c+1",
        "answer_3": "il valore di c+2",
        "answer_4": "il testo 'c++'",
        "currect_answer": "answer_1",
        "module": "modulo 14",
	    "paragraph": "Operatori di assegnazione, incremento e decremento",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'struzione printf( '%d', --c ); stampa:",
        "answer_1": "il valore di c",
        "answer_2": "il valore di c-1",
        "answer_3": "il valore di c-2",
        "answer_4": "il testo '--c'",
        "currect_answer": "answer_2",
        "module": "modulo 14",
	    "paragraph": "Operatori di assegnazione, incremento e decremento",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "Gli operatori di prefisso ++ hanno la precedenza su:",
        "answer_1": "operatori di postfisso ++",
        "answer_2": "operatori di postfisso --",
        "answer_3": "operatori di prefisso --",
        "answer_4": "operatore %",
        "currect_answer": "answer_4",
        "module": "modulo 14",
	    "paragraph": "Overflow aritmetico",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "L'overflow aritmetico determina:",
        "answer_1": "comportamento indefinito",
        "answer_2": "errore di compilazione",
        "answer_3": "errore al linker",
        "answer_4": "nessun problem se le variabili sono di tipo int",
        "currect_answer": "answer_1",
        "module": "modulo 14",
	    "paragraph": "Overflow aritmetico",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "La versione sicura di scanf è:",
        "answer_1": "fscanf",
        "answer_2": "s_scanf",
        "answer_3": "scanf_s",
        "answer_4": "scanf_sec",
        "currect_answer": "answer_3",
        "module": "modulo 14",
	    "paragraph": "Overflow aritmetico",
        "link_pdf": "programmazione_1/dispensa_14"
    },
    {
        "question": "for (unsigned int c = 1; c < = 10; ++c) è",
        "answer_1": "corretta",
        "answer_2": "errata, serve ',' al posto di ';'",
        "answer_3": "errata, serve 'c++' al posto di '++c'",
        "answer_4": "errata, serve 'c==1' al posto di 'c=1'",
        "currect_answer": "answer_1",
        "module": "modulo 16",
	    "paragraph": "L'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "L'istruzione for inizia l'esecuzione:",
        "answer_1": "inizializzando la variabile di controllo",
        "answer_2": "verificando la condizione di continuazione",
        "answer_3": "incrementando/ decrementando il contatore",
        "answer_4": "eseguendo printf della variabile contatore",
        "currect_answer": "answer_1",
        "module": "modulo 16",
	    "paragraph": "L'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Quando il test di continuazione del ciclo fallisce:",
        "answer_1": "Il programma termina con errore",
        "answer_2": "Il programma continua un ultima volta ad eseguire il corpo del ciclo for",
        "answer_3": "Il programma termina con successo",
        "answer_4": "Il programma continua eseguendo la prima istruzione dopo l'istruzione for",
        "currect_answer": "answer_4",
        "module": "modulo 16",
	    "paragraph": "L'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Al termine del ciclo for, la variabile di controllo:",
        "answer_1": "ha il valore della condizione di continuazione del ciclo",
        "answer_2": "riprende il valore iniziale dell'inizializzazione",
        "answer_3": "assume valore 1",
        "answer_4": "assume valore 0",
        "currect_answer": "answer_1",
        "module": "modulo 16",
	    "paragraph": "L'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Le variabili di controllo definite in un'intestazione del for:",
        "answer_1": "esistono fino alla fine della funzione main",
        "answer_2": "esistono solo fino al termine del ciclo",
        "answer_3": "esistono per tutto il programma",
        "answer_4": "esistono solo per la prima iterazione del ciclo",
        "currect_answer": "answer_2",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Errori di tipo off-by-one (sfasamento di uno):",
        "answer_1": "sono errori di sintassi",
        "answer_2": "sono errori logici che determinano un numero errato di cicli for",
        "answer_3": "sono errori logici che determinano un numero imprevedibile di cicli for",
        "answer_4": "Avvengono solo con istruzione for e non con istruzione while",
        "currect_answer": "answer_2",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "L'istruzione for (a1 = 1, a2 = 0; a1 < = 10; ++a1, ++a2) è:",
        "answer_1": "corretta",
        "answer_2": "errata per la doppia inizializzazione",
        "answer_3": "errata per il doppio incremento",
        "answer_4": "errata per l'uso del virgola",
        "currect_answer": "answer_1",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Se nel ciclo for viene omessa l'espressione di condizione:",
        "answer_1": "si genera un errore al linker",
        "answer_2": "si genera un errore di compilazione",
        "answer_3": "si genera un ciclo infinito",
        "answer_4": "il corpo del ciclo non viene eseguito",
        "currect_answer": "answer_3",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "L'istruzione for (c = 10; c > = 1; --c) è:",
        "answer_1": "corretta",
        "answer_2": "errata, serve 'c-=1' al posto di '--c'",
        "answer_3": "errata, si puo' solo incrementare all'interno di un ciclo for",
        "answer_4": "errata, serve '< =' al posto di '> ='",
        "currect_answer": "answer_1",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "Se la condizione di continuazione del ciclo è inizialmente falsa:",
        "answer_1": "si genera un errore al linker",
        "answer_2": "si genera un errore di compilazione",
        "answer_3": "si genera un ciclo infinito",
        "answer_4": "il corpo del ciclo non viene eseguito",
        "currect_answer": "answer_4",
        "module": "modulo 16",
	    "paragraph": "Impiego dell'istruzione for",
        "link_pdf": "programmazione_1/dispensa_16"
    },
    {
        "question": "In while( (ch = getchar()) != EOF ) viene eseguita prima:",
        "answer_1": "while",
        "answer_2": "ch = getchar()",
        "answer_3": "EOF",
        "answer_4": "!=",
        "currect_answer": "answer_2",
        "module": "modulo 18",
	    "paragraph": "La funzione getchar",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "La funzione getchar() :",
        "answer_1": "legge un carattere dalla tastiera e lo memorizza in un buffer",
        "answer_2": "scrive un carattere a video e lo memorizza in un buffer",
        "answer_3": "legge un carattere dalla tastiera e lo ristampa a video",
        "answer_4": "scrive un carattere a video ma non lo memorizza",
        "currect_answer": "answer_1",
        "module": "modulo 18",
	    "paragraph": "La funzione getchar",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "Quando viene chiamata getchar():",
        "answer_1": "Il programma termina con errore",
        "answer_2": "Il programma rimane in attesa",
        "answer_3": "Il programma termina con successo",
        "answer_4": "Il programma continua eseguendo la prima istruzione dopo l'istruzione getchar()",
        "currect_answer": "answer_2",
        "module": "modulo 18",
	    "paragraph": "La funzione getchar",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "L'istruzione printf(\"%c\n\", 'a') stampa:",
        "answer_1": "97a",
        "answer_2": "97",
        "answer_3": "non stampa nulla",
        "answer_4": "a",
        "currect_answer": "answer_4",
        "module": "modulo 18",
	    "paragraph": "Caratteri ed EOF",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "L'ASCII è:",
        "answer_1": "un codice per la codifica numerica di caratteri",
        "answer_2": "una funzione C che associa caratteri a numeri",
        "answer_3": "uno specificatore di conversione",
        "answer_4": "il metodo di memorizzazione per la funzione getchar",
        "currect_answer": "answer_1",
        "module": "modulo 18",
	    "paragraph": "Caratteri ed EOF",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "EOF è:",
        "answer_1": "un carattere speciale che corrisponde a new line",
        "answer_2": "un carattere speciale che corrisponde a \t",
        "answer_3": "una costante intera simbolica",
        "answer_4": "una variabile intera usata per terminare il programma",
        "currect_answer": "answer_3",
        "module": "modulo 18",
	    "paragraph": "Caratteri ed EOF",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "Ctrl d (in linux) o Ctrl z (in Windows) sono interpretati come:",
        "answer_1": "errore",
        "answer_2": "EOF",
        "answer_3": "Invio",
        "answer_4": "getchar()",
        "currect_answer": "answer_2",
        "module": "modulo 18",
	    "paragraph": "Caratteri ed EOF",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "I caratteri devono essere racchiusi entro virgolette singole per essere riconosciuti come:",
        "answer_1": "costanti di tipo carattere",
        "answer_2": "interi di tipo long int",
        "answer_3": "variabili di tipo carattere",
        "answer_4": "stringhe",
        "currect_answer": "answer_1",
        "module": "modulo 18",
	    "paragraph": "Caratteri ed EOF",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "Per gli int l'intervallo minimo va:",
        "answer_1": "da 0 a 65536",
        "answer_2": "da -infinito a +infinito",
        "answer_3": "da 0 a infinito",
        "answer_4": "da -32767 a +32767",
        "currect_answer": "answer_4",
        "module": "modulo 18",
	    "paragraph": "Note sui tipi interi",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "Il tipo di dati char può essere utilizzato per:",
        "answer_1": "memorizzare stringhe di caratteri",
        "answer_2": "rappresentare interi nell'intervallo da -32767 a +32767",
        "answer_3": "eseguire operazioni in virgola mobile",
        "answer_4": "rappresentare interi nell'intervallo da -127 a +127",
        "currect_answer": "answer_4",
        "module": "modulo 18",
	    "paragraph": "Note sui tipi interi",
        "link_pdf": "programmazione_1/dispensa_18"
    },
    {
        "question": "L'istruzione switch realizza una selezione:",
        "answer_1": "singola",
        "answer_2": "doppia",
        "answer_3": "mulitpla",
        "answer_4": "nulla",
        "currect_answer": "answer_3",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: esempio",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "L'istruzione switch include istruzioni per ciascuno dei:",
        "answer_1": "case",
        "answer_2": "default",
        "answer_3": "break",
        "answer_4": "if...else",
        "currect_answer": "answer_1",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: esempio",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "Nei case dell'istruzione switch si esegue il codice specificato dopo:",
        "answer_1": ":",
        "answer_2": "=",
        "answer_3": ":=",
        "answer_4": "{",
        "currect_answer": "answer_1",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: esempio",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "La parola chiave switch è seguita dal nome della variabile tra parentesi:",
        "answer_1": "quadrate",
        "answer_2": "tonde",
        "answer_3": "graffe",
        "answer_4": "angolari",
        "currect_answer": "answer_2",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: approfondimento",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "Il break nell'istruzione switch:",
        "answer_1": "è sempre opzionale sia nei case che neil default",
        "answer_2": "è opzionale solo nel default",
        "answer_3": "è sempre necessario",
        "answer_4": "è opzionale solo nei case",
        "currect_answer": "answer_1",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: approfondimento",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "Il caso default si applica:",
        "answer_1": "Se non si verificano confronti positivi",
        "answer_2": "Se non si verificano confronti negativi",
        "answer_3": "sempre",
        "answer_4": "mai",
        "currect_answer": "answer_1",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: approfondimento",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "Nei case dell'istruzione switch:",
        "answer_1": "puo' essere inclusa una sola azione",
        "answer_2": "devono essere incluse almeno due azioni",
        "answer_3": "non possono essere incluse azioni",
        "answer_4": "puo' essere inclusa una o piu' azioni",
        "currect_answer": "answer_4",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: approfondimento",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "Dimenticare un'istruzione break quando è necessaria in un'istruzione switch è un errore",
        "answer_1": "di compilazione",
        "answer_2": "di sintassi",
        "answer_3": "di esecuzione",
        "answer_4": "di linker",
        "currect_answer": "answer_2",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: approfondimento",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "La clausula di default:",
        "answer_1": "deve presentarsi per ultima dopo i case",
        "answer_2": "e' prassi posizionarla per ultima, dopo i case, ma non è un vincolo",
        "answer_3": "deve presentarsi per prima",
        "answer_4": "e' prassi posizionarla per prima, precedendo i case, ma non è un vincolo",
        "currect_answer": "answer_2",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: diagramma di flusso",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "ogni singolo case dell'istruzione switch può testare solamente un'espressione",
        "answer_1": "variabile di tipo float",
        "answer_2": "costante di tipo carattere",
        "answer_3": "variabile di tipo carattere",
        "answer_4": "costante intera",
        "currect_answer": "answer_4",
        "module": "modulo 19",
	    "paragraph": "L'istruzione switch: diagramma di flusso",
        "link_pdf": "programmazione_1/dispensa_19"
    },
    {
        "question": "L'istruzione di iterazione do..while:",
        "answer_1": "non verifica l'esecuzione del corpo del ciclo",
        "answer_2": "verifica la condizione di continuazione del ciclo prima dell'esecuzione del corpo del ciclo",
        "answer_3": "verifica la condizione di continuazione del ciclo nel corpo del ciclo",
        "answer_4": "verifica la condizione di continuazione del ciclo dopo l'esecuzione del corpo del ciclo",
        "currect_answer": "answer_4",
        "module": "modulo 20",
	    "paragraph": "L'istruzione do..while",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Nell'istruzione di iterazione do..while, la condizione di continuazione deve essere seguita da:",
        "answer_1": ":",
        "answer_2": ";",
        "answer_3": ":=",
        "answer_4": "//",
        "currect_answer": "answer_2",
        "module": "modulo 20",
	    "paragraph": "L'istruzione do..while",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Nell'istruzione di iterazione do..while, l'azione:",
        "answer_1": "viene eseguita almeno 1 volta",
        "answer_2": "viene eseguita almeno 2 volte",
        "answer_3": "viene eseguita almeno fino a EOF",
        "answer_4": "puo' non venire mai eseguita",
        "currect_answer": "answer_1",
        "module": "modulo 20",
	    "paragraph": "L'istruzione do..while",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "L'istruzione break si usa per:",
        "answer_1": "alterare il flusso di controllo",
        "answer_2": "terminare il programma",
        "answer_3": "mettere il programma in attesa",
        "answer_4": "eseguire una chiamata esterna a funzione",
        "currect_answer": "answer_1",
        "module": "modulo 20",
	    "paragraph": "L'istruzione break",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Dopo l'istruzione break in un ciclo for, l'esecuzione del programma:",
        "answer_1": "termina",
        "answer_2": "continua con con l'istruzione successiva al ciclo for",
        "answer_3": "continua con con l'istruzione successiva al break",
        "answer_4": "continua con l'iterazione successiva",
        "currect_answer": "answer_2",
        "module": "modulo 20",
	    "paragraph": "L'istruzione break",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Le istruzioni for (x = 1; x < = 4; ++x) { printf('%s', 'a'); break; printf('%s', 'a'); } stampano:",
        "answer_1": "a",
        "answer_2": "aa",
        "answer_3": "aaa",
        "answer_4": "aaaa",
        "currect_answer": "answer_1",
        "module": "modulo 20",
	    "paragraph": "L'istruzione break",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "L'istruzione continue si usa per:",
        "answer_1": "alterare il flusso di controllo",
        "answer_2": "terminare il programma",
        "answer_3": "riprendere il programma che era stato posto in attesa",
        "answer_4": "eseguire una chiamata esterna a funzione",
        "currect_answer": "answer_1",
        "module": "modulo 20",
	    "paragraph": "L'istruzione continue",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Dopo l'istruzione continue in un ciclo for, l'esecuzione del programma:",
        "answer_1": "termina",
        "answer_2": "continua con con l'istruzione successiva al ciclo for",
        "answer_3": "continua con con l'istruzione successiva al continue",
        "answer_4": "continua con l'iterazione successiva",
        "currect_answer": "answer_4",
        "module": "modulo 20",
	    "paragraph": "L'istruzione continue",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Le istruzioni for (x = 1; x < = 4; ++x) { printf('%s', 'a'); continue; printf('%s', 'a');} stampano:",
        "answer_1": "a",
        "answer_2": "aa",
        "answer_3": "aaaaaaaa",
        "answer_4": "aaaa",
        "currect_answer": "answer_4",
        "module": "modulo 20",
	    "paragraph": "L'istruzione continue",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "All'interno di una iterazione while, la sequenza di istruzioni break; continue; determina:",
        "answer_1": "che l'istruzione continue non sia mai eseguita",
        "answer_2": "che l'istruzione break non sia mai eseguita",
        "answer_3": "che entrambe le istruzioni break e continue siano eseguite",
        "answer_4": "che il loro effetto si annulli, proseguendo con l'istruzione successiva",
        "currect_answer": "answer_1",
        "module": "modulo 20",
	    "paragraph": "L'istruzione continue",
        "link_pdf": "programmazione_1/dispensa_20"
    },
    {
        "question": "Un operatore logico è:",
        "answer_1": ">",
        "answer_2": "?",
        "answer_3": "=",
        "answer_4": "!",
        "currect_answer": "answer_4",
        "module": "modulo 22",
	    "paragraph": "Operatore logico AND (&&)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'istruzione if (x == 2 && y >= 120) è vera se:",
        "answer_1": "x è uguale a 2 e y uguale a 1000",
        "answer_2": "x è uguale a 1 e y uguale a 120",
        "answer_3": "x è uguale a 2 e y uguale a 102",
        "answer_4": "x è uguale a -2 e y uguale a -3",
        "currect_answer": "answer_1",
        "module": "modulo 22",
	    "paragraph": "Operatore logico AND (&&)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "Se espressione1 vale 0 ed espressione2 vale 'nonzero', espressione1&&espressione2 vale:",
        "answer_1": "0",
        "answer_2": "1",
        "answer_3": "nonzero",
        "answer_4": "espressione1 * espressione2",
        "currect_answer": "answer_1",
        "module": "modulo 22",
	    "paragraph": "Operatore logico AND (&&)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'istruzione if (x == 2 || y>= 120) è falsa se:",
        "answer_1": "x è uguale a 2 e y uguale a 1000",
        "answer_2": "x è uguale a 1 e y uguale a 120",
        "answer_3": "x è uguale a 2 e y uguale a 102",
        "answer_4": "x è uguale a -2 e y uguale a -3",
        "currect_answer": "answer_4",
        "module": "modulo 22",
	    "paragraph": "Operatore logico OR (||)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "Se espressione1 vale 0 ed espressione2 vale 'nonzero', espressione1||espressione2 vale:",
        "answer_1": "0",
        "answer_2": "1",
        "answer_3": "nonzero",
        "answer_4": "espressione1 * espressione2",
        "currect_answer": "answer_2",
        "module": "modulo 22",
	    "paragraph": "Operatore logico OR (||)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'operatore ||:",
        "answer_1": "ha una precedenza più alta di &&",
        "answer_2": "ha una precedenza più bassa di &&",
        "answer_3": "ha la stessa precedenza di &&",
        "answer_4": "non ha precedenze",
        "currect_answer": "answer_2",
        "module": "modulo 22",
	    "paragraph": "Operatore logico OR (||)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "Gli operatori && e ||:",
        "answer_1": "|| è associativo da destra a sinistra. && è associativo da sinistra a destra",
        "answer_2": "&& è associativo da destra a sinistra. || è associativo da sinistra a destra",
        "answer_3": "sono entrambi associativi da sinistra a destra",
        "answer_4": "sono entrambi associativi da destra a sinistra",
        "currect_answer": "answer_3",
        "module": "modulo 22",
	    "paragraph": "Operatore logico OR (||)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'istruzione if (x == 2 || y>= 120) viene eseguita piu' velocemente se:",
        "answer_1": "x=2",
        "answer_2": "y=120",
        "answer_3": "x=2 e y=120",
        "answer_4": "x=20 e y=12",
        "currect_answer": "answer_1",
        "module": "modulo 22",
	    "paragraph": "Operatore logico OR (||)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'istruzione if(!(x >= 2)) :",
        "answer_1": "è vera se x=1",
        "answer_2": "è vera se x=2",
        "answer_3": "è vera se x=3",
        "answer_4": "non è scritta correttamente",
        "currect_answer": "answer_1",
        "module": "modulo 22",
	    "paragraph": "Operatore logico NOT (!)",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "L'espressione !(condizione1 && condizione2) è equivalente a:",
        "answer_1": "(condizione1 && condizione2)",
        "answer_2": "(condizione1 || condizione2)",
        "answer_3": "!(condizione1 || condizione2)",
        "answer_4": "(!condizione1 || !condizione2)",
        "currect_answer": "answer_4",
        "module": "modulo 22",
	    "paragraph": "Precedenze e leggi di De Morgan",
        "link_pdf": "programmazione_1/dispensa_22"
    },
    {
        "question": "Il diagramma di flusso per istruzioni di sequenza è:",
        "answer_1": "una sequenza di cerchietti",
        "answer_2": "una sequenza di rettangoli",
        "answer_3": "una sequenza di rombi",
        "answer_4": "una sequenza di rettangoli arrotondati",
        "currect_answer": "answer_2",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Il diagramma di flusso per istruzioni if è composto da:",
        "answer_1": "rombo e rettangolo",
        "answer_2": "rettangolo e rettangolo arrotondato",
        "answer_3": "rombo e due rettangoli",
        "answer_4": "sequenza di rombi e rettangoli",
        "currect_answer": "answer_1",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Il diagramma di flusso per istruzioni if…else è composto da:",
        "answer_1": "rombo e rettangolo",
        "answer_2": "rettangolo e rettangolo arrotondato",
        "answer_3": "rombo e due rettangoli",
        "answer_4": "sequenza di rombi e rettangoli",
        "currect_answer": "answer_3",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Il diagramma di flusso per istruzioni switch è composto da:",
        "answer_1": "rombo e rettangolo",
        "answer_2": "rettangolo e rettangolo arrotondato",
        "answer_3": "rombo e due rettangoli",
        "answer_4": "sequenza di rombi e rettangoli",
        "currect_answer": "answer_4",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Il diagramma di flusso per istruzioni do…while è composto da:",
        "answer_1": "rombo e rettangolo",
        "answer_2": "rettangolo e rettangolo arrotondato",
        "answer_3": "rombo e due rettangoli",
        "answer_4": "sequenza di rombi e rettangoli",
        "currect_answer": "answer_1",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Il diagramma di flusso per istruzioni while è composto da:",
        "answer_1": "rombo e rettangolo",
        "answer_2": "rettangolo e rettangolo arrotondato",
        "answer_3": "rombo e due rettangoli",
        "answer_4": "sequenza di rombi e rettangoli",
        "currect_answer": "answer_1",
        "module": "modulo 23",
	    "paragraph": "Riepilogo istruzioni di controllo",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Collegare istruzioni di controllo in sequenza per formare programmi strutturati è detto:",
        "answer_1": "annidamento",
        "answer_2": "accatastamento",
        "answer_3": "iterazione",
        "answer_4": "assemblaggio",
        "currect_answer": "answer_2",
        "module": "modulo 23",
	    "paragraph": "Regole per costruire programmi strutturati",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Le regole per costruire programmi strutturati indicano che qualsiasi rettangolo (azione) può essere sostituito con:",
        "answer_1": "due rettangoli con ricircolo",
        "answer_2": "due rombi con ricircolo",
        "answer_3": "due rettangoli in sequenza",
        "answer_4": "due rombi in sequenza",
        "currect_answer": "answer_3",
        "module": "modulo 23",
	    "paragraph": "Regole per costruire programmi strutturati",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "La programmazione strutturata prevede l'uso solo di:",
        "answer_1": "accatastamento",
        "answer_2": "annidamento",
        "answer_3": "accatastamento, annidamento o sovrapposizione",
        "answer_4": "accatastamento o annidamento",
        "currect_answer": "answer_4",
        "module": "modulo 23",
	    "paragraph": "Regole per costruire programmi strutturati",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "Qualsiasi forma di controllo in C può essere espressa in termini di solo:",
        "answer_1": "sequenza, for, switch",
        "answer_2": "sequenza, while, if",
        "answer_3": "sequenza, do…while, if…else",
        "answer_4": "sequenza",
        "currect_answer": "answer_2",
        "module": "modulo 23",
	    "paragraph": "Programmazione con semplicità",
        "link_pdf": "programmazione_1/dispensa_23"
    },
    {
        "question": "La libreria standard del C fornisce funzioni per eseguire:",
        "answer_1": "grafica avanzata",
        "answer_2": "comuni calcoli matematici, manipolazioni di stringhe, input/output, giochi tradizionali",
        "answer_3": "calcoli matematici di ogni tipo",
        "answer_4": "comuni calcoli matematici, manipolazioni di stringhe, input/output",
        "currect_answer": "answer_4",
        "module": "modulo 24",
	    "paragraph": "Modularizzazione dei programmi in C",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Le funzioni definite dal programmatore:",
        "answer_1": "sono scritte una sola volta e sono nascoste alle altre funzioni",
        "answer_2": "sono scritte una sola volta e sono visibili alle altre funzioni",
        "answer_3": "sono scritte piu' di una volta e sono nascoste alle altre funzioni",
        "answer_4": "sono scritte piu' di una volta e sono visibili alle altre funzioni",
        "currect_answer": "answer_1",
        "module": "modulo 24",
	    "paragraph": "Modularizzazione dei programmi in C",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "La chiamata di funzione:",
        "answer_1": "specifica solo il nome della funzione",
        "answer_2": "fornisce solo gli argomenti",
        "answer_3": "specifica il nome della funzione e fornisce gli argomenti",
        "answer_4": "specifica l'invocazione gerarchica annidata dei parametri di funzione",
        "currect_answer": "answer_3",
        "module": "modulo 24",
	    "paragraph": "Modularizzazione dei programmi in C",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Le variabili definite nelle definizioni di funzione:",
        "answer_1": "sono tutte locali",
        "answer_2": "possono essere sia locali che non locali",
        "answer_3": "sono modulari",
        "answer_4": "sono tutte non locali",
        "currect_answer": "answer_1",
        "module": "modulo 24",
	    "paragraph": "Introduzione alle funzioni",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Far svolgere a ciascuna funzione un compito specifico si dice:",
        "answer_1": "modularizzazione",
        "answer_2": "astrazione",
        "answer_3": "scomposizione",
        "answer_4": "funzionalizzazione",
        "currect_answer": "answer_2",
        "module": "modulo 24",
	    "paragraph": "Introduzione alle funzioni",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Spezzare una funzione in varie funzioni più piccole si dice:",
        "answer_1": "modularizzazione",
        "answer_2": "astrazione",
        "answer_3": "scomposizione",
        "answer_4": "funzionalizzazione",
        "currect_answer": "answer_3",
        "module": "modulo 24",
	    "paragraph": "Introduzione alle funzioni",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Gli argomenti delle funzioni sono racchiusi tra parentesi:",
        "answer_1": "quadrate",
        "answer_2": "tonde",
        "answer_3": "graffe",
        "answer_4": "angolari",
        "currect_answer": "answer_2",
        "module": "modulo 24",
	    "paragraph": "Libreria math",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "le funzioni nella libreria math che restituiscono valori in virgola mobile restituiscono il tipo di dati",
        "answer_1": "float",
        "answer_2": "double",
        "answer_3": "int",
        "answer_4": "double o float",
        "currect_answer": "answer_2",
        "module": "modulo 24",
	    "paragraph": "Libreria math",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Per usare le funzioni della libreria math, è necessario includere:",
        "answer_1": "#include < math.h >",
        "answer_2": "include < math.h >",
        "answer_3": "#include < math >",
        "answer_4": "include math.h",
        "currect_answer": "answer_1",
        "module": "modulo 24",
	    "paragraph": "Libreria math",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Il valore assoluto di (y*y*y-3) si scrive:",
        "answer_1": "pow( fabs( y,-3 ) 3 )",
        "answer_2": "pow( fabs( y,3 ) -3 )",
        "answer_3": "fabs( pow( y,3 ) -3 )",
        "answer_4": "fabs( pow( y,-3 ) 3 )",
        "currect_answer": "answer_3",
        "module": "modulo 24",
	    "paragraph": "Libreria math",
        "link_pdf": "programmazione_1/dispensa_24"
    },
    {
        "question": "Il prototipo di una funzione va inserito:",
        "answer_1": "nel main o in altra funzione",
        "answer_2": "dopo la chiamata a funzione",
        "answer_3": "in qualunque punto del programma",
        "answer_4": "prima di usare la funzione",
        "currect_answer": "answer_4",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "L'istruzione int funz(double y); indica che:",
        "answer_1": "funz si aspetta di ricevere un valore double",
        "answer_2": "funz restituisce un valore double",
        "answer_3": "funz si aspetta di ricevere un valore int",
        "answer_4": "funz restituisce un valore int",
        "currect_answer": "answer_1",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "L'int alla sinistra del nome della funzione informa il compilatore che:",
        "answer_1": "la funzione restituisce un intero",
        "answer_2": "la funzione richiede un input intero",
        "answer_3": "la funzione opera esclusivamente con variabili intere",
        "answer_4": "la funzione non richiede un intero",
        "currect_answer": "answer_1",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "Il compilatore utilizza il prototipo della funzione per accertarsi che:",
        "answer_1": "il tipo di ritorno sia coerente con il contesto nel quale è chiamata la funzione",
        "answer_2": "i tipi degli argomenti non siano inclusi",
        "answer_3": "i tipi degli argomenti non siano ordinati",
        "answer_4": "il numero di argomenti sia maggiore o uguale a quello della definizione",
        "currect_answer": "answer_1",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "La chiamata di una funzione è invocata:",
        "answer_1": "in qualunque punto del programma",
        "answer_2": "prima del prototipo",
        "answer_3": "nel main o in altra funzione",
        "answer_4": "nella sua definizione",
        "currect_answer": "answer_3",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "La definizione di una funzione è inserita:",
        "answer_1": "prima il prototipo",
        "answer_2": "dopo il prototipo",
        "answer_3": "all'interno del main",
        "answer_4": "all'interno della sua dichiarazione",
        "currect_answer": "answer_2",
        "module": "modulo 25",
	    "paragraph": "Prototipo, chiamata e definizione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "Il tipo di valore di ritorno void indica che una funzione",
        "answer_1": "restituisce la stringa void",
        "answer_2": "non richiede alcuna variabile di input",
        "answer_3": "non restituisce alcun valore",
        "answer_4": "restituisce 0 se corretta, non zero se errata",
        "currect_answer": "answer_3",
        "module": "modulo 25",
	    "paragraph": "Formato e corpo",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "La lista di parametri da passare a una funzione è un elenco separato da",
        "answer_1": "punto ( . )",
        "answer_2": "trattino ( - )",
        "answer_3": "punto e virgola ( ; )",
        "answer_4": "virgola ( , )",
        "currect_answer": "answer_4",
        "module": "modulo 25",
	    "paragraph": "Formato e corpo",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "L'istruzione int funz(int x, y, double z); è:",
        "answer_1": "errata perché non si possono dichiarare int e double nella stessa lista argomenti",
        "answer_2": "corretta",
        "answer_3": "errata perché non si può omettere int per la variabile y",
        "answer_4": "errata perché non si possono indicare più di due argomenti",
        "currect_answer": "answer_3",
        "module": "modulo 25",
	    "paragraph": "Formato e corpo",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "Il main restituisce:",
        "answer_1": "0 se return è omessa",
        "answer_2": "errore se return è omessa",
        "answer_3": "1 se return è omessa",
        "answer_4": "non zero se return e' incluso",
        "currect_answer": "answer_1",
        "module": "modulo 25",
	    "paragraph": "Restituzione",
        "link_pdf": "programmazione_1/dispensa_25"
    },
    {
        "question": "Il compilatore usa i prototipi di funzione per:",
        "answer_1": "definire le funzioni",
        "answer_2": "correggere errori di programmazione",
        "answer_3": "convalidare le chiamate delle funzioni",
        "answer_4": "chiamare le funzioni nel main",
        "currect_answer": "answer_3",
        "module": "modulo 26",
	    "paragraph": "Approfondimento su prototipi di funzioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "La riga del prototipo di funzione si conclude con:",
        "answer_1": "{",
        "answer_2": ";",
        "answer_3": "}",
        "answer_4": ")",
        "currect_answer": "answer_2",
        "module": "modulo 26",
	    "paragraph": "Approfondimento su prototipi di funzioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "La riga della definizione di funzione si conclude con",
        "answer_1": "{",
        "answer_2": ";",
        "answer_3": "}",
        "answer_4": ")",
        "currect_answer": "answer_1",
        "module": "modulo 26",
	    "paragraph": "Approfondimento su prototipi di funzioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Includere i nomi dei parametri nei prototipi",
        "answer_1": "è necessario (se non presenti si generano errori di compilazione)",
        "answer_2": "è facoltativo ma consigliabile",
        "answer_3": "è facoltativo ma sconsigliabile",
        "answer_4": "è da evitare (se presenti si generano errori di compilazionee)",
        "currect_answer": "answer_2",
        "module": "modulo 26",
	    "paragraph": "Approfondimento su prototipi di funzioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Il tipo void nel prototipo di funzione richiede",
        "answer_1": "il tipo int nella corrispondente definizione di funzione",
        "answer_2": "nessun tipo specificato nella corrispondente definizione di funzione",
        "answer_3": "un tipo qualsiasi nella corrispondente definizione di funzione",
        "answer_4": "il tipo void nella corrispondente definizione di funzione",
        "currect_answer": "answer_4",
        "module": "modulo 26",
	    "paragraph": "Approfondimento su prototipi di funzioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Per 'coercizione degli argomenti' si intende:",
        "answer_1": "l'impossibilità di modificare il valore degli argomenti",
        "answer_2": "l'impossibilità di modificare il tipo degli argomenti",
        "answer_3": "la forzatura del valore degli argomenti",
        "answer_4": "la forzatura del tipo degli argomenti",
        "currect_answer": "answer_4",
        "module": "modulo 26",
	    "paragraph": "Coercizione degli argomenti e conversioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "la conversione di un double in un int:",
        "answer_1": "avviene per troncamento",
        "answer_2": "avviene per approssimazione all'intero superiore",
        "answer_3": "avviene senza perdita di accuratezza",
        "answer_4": "non è gestibile dal compilatore (restiuisce errore)",
        "currect_answer": "answer_1",
        "module": "modulo 26",
	    "paragraph": "Coercizione degli argomenti e conversioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "In un'espressione con tipi misti, il compilatore:",
        "answer_1": "converte tutti i tipi presenti in int",
        "answer_2": "converte tutti i tipi presenti in double",
        "answer_3": "converte tutti i tipi presenti in long double",
        "answer_4": "esegue una copia temporanea dei valori da convertire",
        "currect_answer": "answer_4",
        "module": "modulo 26",
	    "paragraph": "Coercizione degli argomenti e conversioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Un valore si può convertire in un tipo più basso usando:",
        "answer_1": "cast",
        "answer_2": "void",
        "answer_3": "return",
        "answer_4": "double",
        "currect_answer": "answer_1",
        "module": "modulo 26",
	    "paragraph": "Coercizione degli argomenti e conversioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Se uno dei valori è long double, l'altro si converte in",
        "answer_1": "long double",
        "answer_2": "double",
        "answer_3": "long int",
        "answer_4": "int",
        "currect_answer": "answer_1",
        "module": "modulo 26",
	    "paragraph": "Coercizione degli argomenti e conversioni",
        "link_pdf": "programmazione_1/dispensa_26"
    },
    {
        "question": "Nel C la struttura dati è nota come:",
        "answer_1": "record di attivazione",
        "answer_2": "stack",
        "answer_3": "funzione",
        "answer_4": "automatica",
        "currect_answer": "answer_2",
        "module": "modulo 27",
	    "paragraph": "Stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Nel C la struttura dati è di tipo LIFO:",
        "answer_1": "l'ultimo elemento inserito è l'ulitmo a essere rimosso",
        "answer_2": "l'ultimo elemento inserito è il primo a essere rimosso",
        "answer_3": "gli elementi inseriti sono rimossi in ordine random",
        "answer_4": "il primo elemento inserito è il primo a essere rimosso",
        "currect_answer": "answer_2",
        "module": "modulo 27",
	    "paragraph": "Stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Le variabili automatiche sono:",
        "answer_1": "variabili locali delle funzioni",
        "answer_2": "variabili il cui tipo è convertito automaticamente",
        "answer_3": "variabili locali della sola funzione main",
        "answer_4": "variabili il cui valore è convertito automaticamente",
        "currect_answer": "answer_1",
        "module": "modulo 27",
	    "paragraph": "Stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Ogni funzione alla fine deve restituire il controllo:",
        "answer_1": "al main",
        "answer_2": "alla funzione chiamata",
        "answer_3": "al sistema operativo",
        "answer_4": "alla funzione chiamante",
        "currect_answer": "answer_4",
        "module": "modulo 27",
	    "paragraph": "Stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Il record di attivazione contiene:",
        "answer_1": "l'indirizzo di ritorno alla funzione chiamata",
        "answer_2": "l'indirizzo di ritorno alla funzione chiamante",
        "answer_3": "l'indirizzo di ritorno alla funzione chiamata e le variabili locali",
        "answer_4": "l'indirizzo di ritorno alla funzione chiamante e le variabili locali",
        "currect_answer": "answer_4",
        "module": "modulo 27",
	    "paragraph": "Record di attivazione",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Se la funzione chiamata torna alla funzione chiamante:",
        "answer_1": "si esegue il push del record di attivazione della funzione chiamata",
        "answer_2": "si esegue il pop del record di attivazione della funzione chiamata",
        "answer_3": "si esegue il push del record di attivazione della funzione chiamante",
        "answer_4": "si esegue il pop del record di attivazione della funzione chiamante",
        "currect_answer": "answer_2",
        "module": "modulo 27",
	    "paragraph": "Record di attivazione",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Quando una funzione chiamata torna alla sua funzione chiamante:",
        "answer_1": "le variabili automatiche della funzione chiamata vengono rimosse",
        "answer_2": "le variabili automatiche della funzione chiamante vengono rimosse",
        "answer_3": "le variabili globali della funzione chiamata vengono rimosse",
        "answer_4": "le variabili globali della funzione chiamata vengono rimosse",
        "currect_answer": "answer_1",
        "module": "modulo 27",
	    "paragraph": "Record di attivazione",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Si verifica uno stack overflow quando:",
        "answer_1": "sono stati rimossi tutti record di attivazione",
        "answer_2": "si verifica un errore irreverisbile di compilazione",
        "answer_3": "si esaurisce la memoria per i record di attivazione",
        "answer_4": "si utilizzano più record di attivazione di quante funzioni sono state create",
        "currect_answer": "answer_3",
        "module": "modulo 27",
	    "paragraph": "Esempio di uso dello stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "Quando si raggiunge la parentesi graffa destra di chiusura di main avviene:",
        "answer_1": "la sola rimozione del record dallo stack ma non si realizza il ritorno al sistema operativo",
        "answer_2": "il ritorno al sistema operativo ma il record dallo stack viene mantenuto",
        "answer_3": "prima la rimozione del record dallo stack e quindi il ritorno al sistema operativo",
        "answer_4": "la rimozione del sistema operativo",
        "currect_answer": "answer_3",
        "module": "modulo 27",
	    "paragraph": "Esempio di uso dello stack",
        "link_pdf": "programmazione_1/dispensa_27"
    },
    {
        "question": "A fine esecuzione, la memoria per le variabili automatiche di main:",
        "answer_1": "non è più accessibile",
        "answer_2": "rimane accessibile in sola lettura",
        "answer_3": "rimane accessibile in sola scrittura",
        "answer_4": "rimane accessibile in lettura e scrittura",
        "currect_answer": "answer_1",
        "module": "modulo 27",
	    "paragraph": "Esempio di uso dello stack",
        "link_pdf": "programmazione_1/dispensa_27"
    }
]